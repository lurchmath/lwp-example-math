{"version":3,"sources":["lwp-example-math.litcoffee"],"names":["inspect","menu","setAppName","addHelpMenuSourceCodeLink","window","helpAboutText","pluginsToLoad","push","groupTypes","name","text","tooltip","color","imageHTML","openImageHTML","closeImageHTML","contentsChanged","group","firstTime","info","OMNode","type","children","simpleEncode","set","tagContents","get","tagMenuItems","contextMenuItems","e","nodes","parsed","ref","selector","toParse","$","contentNodes","find","add","filter","length","mathQuillToMeaning","error","message","mathQuillParser","parse","join","onclick","ref1","alert","toXML","result","evaluate","value"],"mappings":"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","file":"lwp-example-math.js","sourcesContent":["\n# Mathematical Example Application, Lurch Web Platform\n\n## Overview\n\nTo know what's going on here, you should first have read the documenation\nfor [the simple example application](simple-example-solo.litcoffee) and then\nfor [the complex example application](complex-example-solo.litcoffee).\n\nThis application, too, is an example application built on the [Lurch Web\nPlatform (LWP)](https://github.com/lurchmath/lurch), but it is more\ninteresting than the two above, because it shows how to incorporate an\nequation editor and OpenMath semantics into an application (albeit in a\nvery simple way).\n\n    setAppName 'MathApp'\n    addHelpMenuSourceCodeLink \\\n        'lwp-example-math/blob/master/lwp-example-math.litcoffee'\n    window.helpAboutText =\n        '<p>See the fully documented <a target=\"top\"\n        href=\"https://github.com/lurchmath/lwp-example-math/blob/master/lwp-example-math.litcoffee\"\n        >source code for this demo app</a>.</p>'\n\n[A live version of this app is online here.](https://lurchmath.github.io/lwp-example-math)\n\nThis application needs the equation editor plugin, so we must tell the setup\nscript to load it, by modifying the following global variable.\n\n    window.pluginsToLoad.push 'equationeditor'\n\n## Define one group type\n\nThis initialization code is similar to that in the two simpler example\napplications linked to above.  This file assumes you've read those.\n\n    window.groupTypes = [\n        name : 'me'\n        text : 'Mathematical Expression'\n        tooltip : 'Make the selection a mathematical expression'\n        color : '#666699'\n        imageHTML : '<font color=\"#666699\"><b>[ ]</b></font>'\n        openImageHTML : '<font color=\"#666699\"><b>[</b></font>'\n        closeImageHTML : '<font color=\"#666699\"><b>]</b></font>'\n\nThe `contentsChanged` function is called on a group whenever that group just\nhad its contents changed.  In this case, we analyze the contents of the\nbubble tag and store the results of that analysis in the group.\n\nThe `inspect` function is central here, and is defined in [the following\nsection](#utility-functions-used-by-the-code-above).  It returns an\n[OpenMath](http://www.openmath.org) data structure (as defined in [the\nOpenMath JavaScript repository](https://github.com/lurchmath/openmath-js)),\nwhich we can inspect to learn about the semantics of the group contents.\n\n        contentsChanged : ( group, firstTime ) ->\n            info = inspect group\n            if info instanceof window.OMNode\n                info = switch info.type\n\nLabel all basic types with the name of the basic type itself:\n\n                    when 'i' then 'integer'\n                    when 'f' then 'float'\n                    when 'st' then 'string'\n                    when 'ba' then 'byte array'\n                    when 'sy' then 'symbol'\n                    when 'v' then 'variable'\n\nLabel a function application with a name determined by the function or\noperator being applied:\n\n                    when 'a' then switch info.children[0].simpleEncode()\n                        when 'arith1.plus', 'arith1.sum' then 'sum'\n                        when 'arith1.minus' then 'difference'\n                        when 'arith1.plusminus' then 'sum/difference'\n                        when 'arith1.times' then 'product'\n                        when 'arith1.divide' then 'quotient'\n                        when 'arith1.power' then 'exponentiation'\n                        when 'arith1.root' then 'radical'\n                        when 'arith1.abs' then 'absolute value'\n                        when 'arith1.unary_minus' then 'negation'\n                        when 'relation1.eq' then 'equation'\n                        when 'relation1.approx' then 'approximation'\n                        when 'relation1.neq' then 'negated equation'\n                        when 'relation1.lt', 'relation1.le', \\\n                             'relation1.gt', 'relation1.ge'\n                            'inequality'\n                        when 'logic1.not' then 'negated sentence'\n                        when 'calculus1.int' then 'indefinite integral'\n                        when 'calculus1.defint' then 'definite integral'\n                        when 'transc1.sin', 'transc1.cos', 'transc1.tan', \\\n                             'transc1.cot', 'transc1.sec', 'transc1.csc'\n                            'trigonometric function'\n                        when 'transc1.arcsin', 'transc1.arccos', \\\n                             'transc1.arctan', 'transc1.arccot', \\\n                             'transc1.arcsec', 'transc1.arccsc'\n                            'inverse trigonometric function'\n                        when 'overarc' then 'overarc'\n                        when 'overline' then 'overline'\n                        when 'd.diff' then 'differential'\n                        when 'interval1.interval_oo', \\\n                             'interval1.interval_oc', \\\n                             'interval1.interval_co', \\\n                             'interval1.interval_cc' then 'interval'\n                        when 'integer1.factorial' then 'factorial'\n                        when 'limit1.limit' then 'limit'\n\nLabel a binding expression as a lambda closure, since that's the only kind\nsupported by this application:\n\n                    when 'b' then 'lambda closure'\n\nWe store the results of the inpection in an attribute of the group, so that\nit's easy to look up later, when we need to place it in the bubble tag.\n\n            group.set 'tag', info\n\nWhen the application requests that we compute the group's tag, we just lift\nthe data out of the result already stored in the group from the above\ncomputation, and use that as the contents of the bubble tag.\n\n        tagContents : ( group ) -> group.get 'tag'\n\nClicking the tag or the context menu brings up the same menu, defined in\n[the menu function below](#utility-functions-used-by-the-code-above).\n\n        tagMenuItems : ( group ) -> menu group\n        contextMenuItems : ( group ) -> menu group\n    ]\n\n## Utility functions used by the code above\n\nThe `inspect` function tries to interpret the contents of the group as\ncontaining a single [MathQuill](http://mathquill.com/) instance.  (The LWP\ncomes with the built-in ability to insert MathQuill instances into documents\nas WYSIWYG math expression editors.  It resides in the [eqed](eqed/) folder,\nimported from [the LWP\nrepository](https://github.com/lurchmath/lurch/tree/master/source/assets/eqed).)\n\nThe `inspect` function returns one of two things.\n * If it returns an `OMNode` instance, it will be the meaning of the one\n   MathQuill instance in the bubble, implying that there is one such\n   instance in the group, and a meaning is parseable from it using [the\n   MathQuill parser defined in the\n   LWP](https://github.com/lurchmath/lurch/blob/master/source/auxiliary/mathquill-parser.litcoffee).\n * If an error arose in attempting such a computation, then a string will\n   be returned containing the error.\n\n\n    inspect = ( group ) ->\n        nodes = $ group.contentNodes()\n        selector = '.mathquill-rendered-math'\n        nodes = nodes.find( selector ).add nodes.filter selector\n        if nodes.length is 0 then return 'add math using the f(x) button'\n        if nodes.length > 1 then return 'more than one math expression'\n        try\n            toParse = window.mathQuillToMeaning nodes.get 0\n        catch e\n            return \"Error converting math expression to text: #{e?.message}\"\n        try\n            parsed = mathQuillParser.parse( toParse )?[0]\n        catch e\n            return \"Error parsing math expression as text: #{e?.message}\"\n        if parsed instanceof OMNode then return parsed\n        \"Could not parse this mathematical text: #{toParse?.join? ' '} --\n            Error: #{parsed}\"\n\nThe following function provides the contents of either the tag menu or the\ncontext menu for a group; both are the same.  They contain two menu items.\n\n    menu = ( group ) -> [\n\nThe first shows the full OpenMath structure of a group's meaning, as XML.\nIt uses the `toXML` function defined [near the end of the OpenMath\nmodule](https://github.com/lurchmath/openmath-js/blob/master/openmath.litcoffee#converting-mathematical-expressions-to-xml).\n\n        text : 'See full OpenMath structure'\n        onclick : ->\n            if ( info = inspect group ) not instanceof OMNode\n                alert \"Could not understand the bubble contents:\\n #{info}\"\n            else\n                try\n                    alert info.toXML() ? \"This demo could not convert some\n                        part of that expression to XML.\"\n                catch e then alert e.message ? e\n\nThe second is for evaluating the group's contents, as a mathematical\nexpression.  It uses the `evaluate` function defined [at the end of the\nOpenMath\nmodule](https://github.com/lurchmath/openmath-js/blob/master/openmath.litcoffee#evaluating-mathematical-expressions-numerically).\n\n    ,\n        text : 'Evaluate this'\n        onclick : ->\n            if ( info = inspect group ) not instanceof OMNode\n                info = \"Could not understand the bubble contents:\\n#{info}\"\n            else\n                result = info.evaluate()\n                info = \"#{result.value}\"\n                if result.message?\n                    info += \"\\n\\nNote:\\n#{result.message}\"\n            alert info\n    ]\n"]}